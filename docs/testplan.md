# План E2E тестирования Hotel Booking (MVP)

## Введение
- Система: API Gateway + Booking (планируется) + Inventory (реализован). Все вызовы через HTTP; базовый URL `http://localhost:8000` для Inventory; Gateway/Booking предполагается на `http://localhost:8080`.
- Охват MVP: поиск доступности, создание hold (временная бронь), подтверждение, отмена, истечение TTL hold, идемпотентность повторных вызовов, консистентность доступности между Booking и Inventory.
- Предусловия общие: применены миграции обоих сервисов; Inventory заполнен сидовыми данными `data/room_types_data.sql` и `data/test_inventory_daily_data.sql`; Booking БД пустая (нет hold/booking); настройки времени в UTC; TTL hold можно упростить до 1 минуты для демонстрации; перед каждым тестом восстановить чистое состояние БД.
- Принятые контракты Booking (так как код еще не написан):
  - `POST /holds` -> 201, тело: `{"hold_id": "...","status":"HOLD","expires_at":"<ISO8601>","room_type_id":"...","check_in":"...","check_out":"...","operation_uuid":"<uuid-used-in-inventory>"}`; 409 при отсутствии доступности `{"code":"NO_AVAILABILITY","message":"No rooms left"}`.
  - `POST /holds/{hold_id}/confirm` -> 200 `{"booking_id":"...","status":"CONFIRMED","room_type_id":"...","check_in":"...","check_out":"..."}`; 409 `{"code":"HOLD_EXPIRED_OR_NOT_FOUND"}` если hold истек/не найден.
  - `POST /holds/{hold_id}/cancel` -> 200 `{"status":"CANCELLED"}`; 409 если уже подтвержден или истек.
  - Идемпотентность: `X-Idempotency-Key` на `POST /holds`; повтор с тем же ключом возвращает тот же `hold_id` без дополнительных резервов.
- Проверка побочных эффектов всегда через Inventory `/rooms/search` и (для нужных кейсов) через повторные вызовы Booking.

## 1. Основная функциональность

### Тест 1.1: Поиск доступности через Gateway
**Цель**: убедиться, что поиск отдает доступные типы с правильной доступностью.

**Предусловия**: чистое сидовое состояние.

**Шаги**:
1. `GET http://localhost:8080/search?adults=4&min_price=8000&max_price=15000&check_in=2025-12-10&check_out=2025-12-12`

**Ожидаемый результат**:
- HTTP 200.
- Ответ:
  ```json
   {
    "room_type_id": "STANDART_A",
    "name": "standard",
    "capacity_adults": 4,
    "price": 12000,
    "total_quantity": 20,
    "available_quantity": 5
  }
   ```

### Тест 1.2: Успешное создание hold
**Цель**: проверить, что hold резервирует инвентарь в Inventory и возвращает корректные данные.

**Предусловия**: сидовое состояние; для `STANDART_A` на 2025-12-10..2025-12-12 доступно 5.

**Шаги**:
1. Зафиксировать исходную доступность: `GET /rooms/search?room_type_id=STANDART_A&check_in=2025-12-10&check_out=2025-12-12` → ожидаем 5.
2. `POST http://localhost:8080/holds` с телом:
   ```json
   {
     "room_type_id": "STANDART_A",
     "check_in": "2025-12-10",
     "check_out": "2025-12-12",
     "adults": 2
   }
   ```
3. Проверить доступность: повтор шага 1.

**Ожидаемый результат**:
- Шаг 2: HTTP 201, `status: "HOLD"`, `hold_id` не пустой, `expires_at` > текущего времени, `operation_uuid` присутствует.
- Шаг 3: `available_quantity` уменьшилось до 4; другие типы не изменились.

### Тест 1.3: Подтверждение hold
**Цель**: убедиться, что подтверждение переводит hold в бронирование, сохраняя резерв.

**Предусловия**: создан hold `POST http://localhost:8080/holds` с телом:
   ```json
   {
     "room_type_id": "STANDART_A",
     "check_in": "2025-12-10",
     "check_out": "2025-12-12",
     "adults": 2
   }
   ```

**Шаги**:
1. `POST http://localhost:8080/holds/{hold_id}/confirm`
2. Проверить доступность: `GET /rooms/search?room_type_id=STANDART_A&check_in=2025-12-10&check_out=2025-12-12`.

**Ожидаемый результат**:
- Шаг 1: HTTP 200, `status: "CONFIRMED"`, `booking_id` не пустой.
- Шаг 2: `available_quantity` осталось 4 (резерв был сделан при hold, не должен измениться повторно).

### Тест 1.4: Отмена hold с возвратом инвентаря
**Цель**: проверить, что отмена освобождает резерв.

**Предусловия**: сидовое состояние; hold не подтвержден.

**Шаги**:
1. Создать hold `POST /holds` для `STANDART_B`, даты 2025-12-10..2025-12-12 (ожидаемый `hold_id`).
2. `POST /holds/{hold_id}/cancel`.
3. Проверить доступность: `GET /rooms/search?room_type_id=STANDART_B&check_in=2025-12-10&check_out=2025-12-12`.

**Ожидаемый результат**:
- Шаг 2: HTTP 200, `status: "CANCELLED"`.
- Шаг 3: `available_quantity` вернулось к исходным 9.

## 2. Ошибки бизнес-логики

### Тест 2.1: Нет доступности при создании hold
**Цель**: получить бизнес-ошибку, когда инвентарь исчерпан.

**Предусловия**: сидовое состояние; `FAMILY_A` на 2025-12-10..2025-12-12 имеет 1 свободный номер.

**Шаги**:
1. Создать hold №1 `POST /holds` с `room_type_id: "FAMILY_A"`, даты 2025-12-10..2025-12-12` — успех.
2. Повторно `POST /holds` с теми же датами/типом — ожидаем ошибку.
3. Проверить `GET /rooms/search?room_type_id=FAMILY_A&check_in=2025-12-10&check_out=2025-12-12`.

**Ожидаемый результат**:
- Шаг 2: HTTP 409, `code: "NO_AVAILABILITY"`.
- Шаг 3: `available_quantity` = 0; нет отрицательных значений.

### Тест 2.2: Подтверждение истекшего/неизвестного hold
**Цель**: убедиться, что просроченный или несуществующий hold не подтверждается.

**Предусловия**: настроить TTL hold = 1 минута; создать hold и дождаться истечения.

**Шаги**:
1. Создать hold `POST /holds` (любой тип, например `STANDART_A`, даты 2025-12-10..2025-12-12).
2. Дождаться TTL (или вызвать служебный endpoint/джобу, чтобы форсировать истечение).
3. `POST /holds/{hold_id}/confirm`.
4. Проверить доступность через Inventory search.

**Ожидаемый результат**:
- Шаг 3: HTTP 409, `code: "HOLD_EXPIRED_OR_NOT_FOUND"`.
- Шаг 4: `available_quantity` вернулась к исходному значению (резерв освобожден).

### Тест 2.3: Отмена подтвержденного бронирования
**Цель**: убедиться, что нельзя отменить уже подтвержденный hold через cancel.

**Предусловия**: создать hold и подтвердить его (статус CONFIRMED).

**Шаги**:
1. `POST /holds/{hold_id}/cancel` (для подтвержденного hold).

**Ожидаемый результат**:
- HTTP 409, сообщение о невозможности отмены подтвержденной брони; `available_quantity` не меняется.

## 3. Идемпотентность

### Тест 3.1: Идемпотентность создания hold
**Цель**: повторный `POST /holds` с тем же `X-Idempotency-Key` не создает новый hold и не резервирует инвентарь повторно.

**Предусловия**: сидовое состояние.

**Шаги**:
1. `POST /holds` c заголовком `X-Idempotency-Key: HOLD-001`, тип `STANDART_A`, даты 2025-12-10..2025-12-12.
2. Повторить тот же запрос с тем же ключом.
3. Проверить доступность Inventory search.

**Ожидаемый результат**:
- Шаги 1 и 2 возвращают одинаковый `hold_id`; второй ответ HTTP 200/201 с признаком "already processed" (явно указать в Booking API).
- `available_quantity` уменьшилась только на 1 (с 5 до 4).

### Тест 3.2: Идемпотентность подтверждения hold
**Цель**: повторное подтверждение возвращает тот же `booking_id` и не меняет инвентарь.

**Предусловия**: hold создан (HOLD-002) и еще не подтвержден.

**Шаги**:
1. `POST /holds/{hold_id}/confirm`.
2. Повторить шаг 1.
3. Проверить доступность Inventory search.

**Ожидаемый результат**:
- Оба вызова HTTP 200; второй возвращает тот же `booking_id` и текст "already confirmed".
- `available_quantity` неизменна между вызовами.

### Тест 3.3: Идемпотентность отмены hold
**Цель**: повторная отмена не делает лишних release в Inventory.

**Предусловия**: hold создан и не подтвержден (HOLD-003).

**Шаги**:
1. `POST /holds/{hold_id}/cancel`.
2. Повторить шаг 1.
3. Проверить доступность Inventory search для типа hold.

**Ожидаемый результат**:
- Второй вызов HTTP 200/204 с сообщением, что hold уже отменен.
- `available_quantity` возвращена к исходной и не уходит в отрицательные значения.

## 4. Консистентность и TTL

### Тест 4.1: Авто-истечение hold (TTL) освобождает резерв
**Цель**: убедиться, что фоновая задача/endpoint очищает просроченные hold и вызывает release в Inventory.

**Предусловия**: TTL=1 минута.

**Шаги**:
1. Создать hold `POST /holds` (любой тип, например `STANDART_C`, даты 2025-12-10..2025-12-12).
2. Дождаться TTL и вызвать задачу истечения (endpoint/CLI Booking, например `/internal/holds/expire`).
3. Проверить доступность Inventory search для `STANDART_C` на эти даты.
4. Попытаться подтвердить истекший hold `POST /holds/{hold_id}/confirm`.

**Ожидаемый результат**:
- После шага 2 `available_quantity` вернулась к исходной.
- Шаг 4: HTTP 409 `HOLD_EXPIRED_OR_NOT_FOUND`.

### Тест 4.2: Согласованность инвентаря между Inventory и Booking
**Цель**: проверить, что статусы hold/booking коррелируют с цифрами доступности.

**Предусловия**: сидовое состояние.

**Шаги**:
1. Создать два hold на `STANDART_A` (разные idempotency-key) — оба успех.
2. Подтвердить один из них, второй отменить.
3. Получить список активных hold/booking через Booking (например, `GET /holds?room_type_id=STANDART_A&range=2025-12-10..2025-12-12`).
4. Проверить `GET /rooms/search` для `STANDART_A` на те же даты.

**Ожидаемый результат**:
- В Booking: 1 запись со статусом CONFIRMED, 1 со статусом CANCELLED.
- В Inventory: `available_quantity` = 4 (начально 5, минус один подтвержденный; отмененный не влияет).
- Нет расхождений: сумма подтвержденных резервов = 1, что совпадает с уменьшением доступности.

### Тест 5: Полный цикл бронирования через Gateway
**Цель**: показать сквозной сценарий search → hold → confirm → проверка инвентаря.

**Предусловия**: сидовое состояние.

**Шаги**:
1. Поиск: `GET http://localhost:8080/search?adults=4&min_price=8000&max_price=15000&check_in=2025-12-10&check_out=2025-12-12` — зафиксировать `available_quantity=5`.
2. Hold: `POST /holds` для `STANDART_A` (новый hold).
3. Confirm: `POST /holds/{hold_id}/confirm`.
4. Проверка доступности: `GET /rooms/search` для `STANDART_A` тех же дат.

**Ожидаемый результат**:
- Hold → HTTP 201, `status: "HOLD"`.
- Confirm → HTTP 200, `status: "CONFIRMED"`, `booking_id` выдан.
- Итоговая доступность `STANDART_A` = 4; нет расхождений с Inventory.
